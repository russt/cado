#define some specialized ops for operating on shell scripts.
{
SH_OP_STUBS := << EOF_OPS
sub factorShSubs_op
{
    my ($var, $varname, $linecnt) = @_;
    my $prefix = "shsub_";
    my $xpat = "";
    my $ipat = "";

    if ( &var_defined_non_empty("CG_SHSUB_PREFIX") ) {
        $prefix = $CG_USER_VARS{'CG_SHSUB_PREFIX'}          
    } else {
        #otherwise, initialize prefix to the default so user can retrieve it:
        &assign_op($prefix, 'CG_SHSUB_PREFIX', $linecnt);
    }

    $xpat =   $CG_USER_VARS{'CG_SHSUB_EXCLUDE_PATTERN'} if ( &var_defined_non_empty("CG_SHSUB_EXCLUDE_PATTERN") );
    $ipat =   $CG_USER_VARS{'CG_SHSUB_INCLUDE_PATTERN'} if ( &var_defined_non_empty("CG_SHSUB_INCLUDE_PATTERN") );

    #remove leading/trailing slashes if necessary:
    ($xpat =~ s|^/|| && $xpat =~ s|/$||) unless ($xpat eq "");
    ($ipat =~ s|^/|| && $ipat =~ s|/$||) unless ($ipat eq "");

    my $have_pattern_specs = ($xpat ne "" | $ipat ne "");

    #clear output variables:
    &assign_op("", 'CG_SHSUB_DEFS', $linecnt);
    &assign_op("", 'CG_SHSUB_LIST', $linecnt);

    #INPUT:
    # a()
    # {
    #     echo sub a: $v_1
    # }
    # 
    # b (  ){
    #     echo sub b: $v2
    #     }
    # 
    # # c() { echo sub c }
    # 
    # c()
    # {
    # echo sub c: $V3
    # }
    #
    # _123()
    # {
    # echo sub _123
    # a=${v2}
    # }
    #
    #OUTPUT:
    # {=shsub_a=}
    # {=shsub_b=}
    # #c() { echo sub c }
    # {=shsub_c=}
    # {=shsub__123=}
    #
    #NOTES:
    # - brackets are only used in var refs & subroutine defs.
    # - expression below requires at least one newline before each subrouting declaration.
    #   this means that we will miss subroutines declared in first line of file.
    # - note the use of .+? in the expression.  this forces the engine to match the first
    #{  instance of \n\s*} which terminates the subroutine def.  otherwise, it would do
    #   a "greedy" match, and match the last instance.
    # - the /so modifiers treat the multi-line string as a single string,
    #   and compile the pattern only once.

    my %shsub_defs = ();
    my %shsub_names = ();
    my @cg_srnames_initial = ();
    my $re = '\n([\t ]*)([a-z_A-Z]\w*)(\s*\(\s*\)[^{]*\{.+?\n\s*\})(\s*?)\n';
    #} match bracket
    my ($cg_srname, $srtxt, $srname, $wsp_leading, $wsp_trailing) = ("", "", "", "", "");

    while ($var =~ /$re/so ) {
        $wsp_leading = $1;
        $srname = $2;
        $srtxt = "$2$3";
        $wsp_trailing = $4;
        $cg_srname = "$prefix$srname";

#printf "srtxt='%s'\n", $srtxt;

#       my $repl = sprintf(">\n{=%s=}%s<", $cg_srname, $wsp_trailing);
        my $repl = sprintf("\n%s{=%s=}%s\n", $wsp_leading, $cg_srname, $wsp_trailing);

        #replace the subroutine text with the generated cg macro name:
        $var =~ s/$re/$repl/so;

        #save the name and text of the subroutine:
        $shsub_defs{$cg_srname} = $srtxt;
        $shsub_names{$cg_srname} = $srname;

        #push the cg sr name on to preserve order of input:
        push @cg_srnames_initial, $cg_srname;
    }

#printf "INTERMEDIATE VAR=,%s,\n", $var;

    #now we loop through the macros names created and restore the original text
    #for subroutines we are ignoring.

    my $srdeftxt = "";
    my (@srnames) = ();
    my (@cg_srnames_final) = ();

    #set pragma to trim final newlines in here-now defs we generate for subroutines.
    #this allows us to substitute macros and restore the spacing of the original text.
    $srdeftxt .= << "!";
\%pragma trim_multiline_rnewline 1

!

    foreach $cg_srname (@cg_srnames_initial) {
        $srtxt = $shsub_defs{$cg_srname};
        $srname = $shsub_names{$cg_srname};
        my $macroref = "{=$cg_srname=}";

        #if this subroutine is excluded by name...
        if ( &sh_name_is_excluded($srname, $ipat, $xpat) ) {
            #... then restore original text in the input:
            $var =~ s/$macroref/$srtxt/s;

            next;   #do not output text or variable if we are excluding
        }

        #otherwise, append to user variables:  definition text, and subroutine name list:
        push @srnames, $srname;
        push @cg_srnames_final, $cg_srname;

        #output definition:
        $srdeftxt .= << "!";

##sh subroutine $srname()
${cg_srname}_ref := $srname
$cg_srname := << EOF
$srtxt
EOF

!
    }

    $srdeftxt .= << "!";

#restore normal behavior for here-now defs:
\%pragma trim_multiline_rnewline 0
!

    ########
    #finally, identifiy all references to the subroutines we have factored out,
    #and replace those references with macros:
    ########
    foreach $cg_srname (@cg_srnames_final) {
        $srname = $shsub_names{$cg_srname};
        my $cg_srname_ref = "${cg_srname}_ref";
        my $macroref = "{=$cg_srname_ref=}";

        $var =~ s/(\s+?)$srname(\s+?)/$1${macroref}$2/sg;
    }

    ######
    #write results to user vars:
    ######
    my $FS = &lookup_def('CG_STACK_DELIMITER');

    #overwrite results if we had any:
    &assign_op($srdeftxt, 'CG_SHSUB_DEFS', $linecnt)          if ($srdeftxt ne "");;
    &assign_op(join($FS, @srnames), 'CG_SHSUB_LIST', $linecnt) if ($#srnames >= 0);

    return $var;
}

sub sh_name_is_excluded
#return 1 if <name> is excluded, 0 otherwise
#(local  utility).
{
    my ($name, $ipat, $xpat) = @_;

    #do not excluded if neither include or exclude pattern was specified:
    return 0 if ($ipat eq "" && $xpat eq "");

    #exclude if exclude pattern is specified and matches:
    return 1 if ($xpat ne "" && $name =~ /$xpat/);

    #do not exclude if include pattern was not specified or if it is specified and matches:
    return 0 if ($ipat eq "" || $name =~ /$ipat/);

    #include pattern was specified, but did not match:
    return 1;
}

sub factorShVars_op
{
    my ($var, $varname, $linecnt) = @_;
    my $prefix = "shvar_";
    my $xpat = "";
    my $ipat = "";

    $prefix = $CG_USER_VARS{'CG_SHVAR_PREFIX'}          if ( &var_defined_non_empty("CG_SHVAR_PREFIX") );
    $xpat =   $CG_USER_VARS{'CG_SHVAR_EXCLUDE_PATTERN'} if ( &var_defined_non_empty("CG_SHVAR_EXCLUDE_PATTERN") );
    $ipat =   $CG_USER_VARS{'CG_SHVAR_INCLUDE_PATTERN'} if ( &var_defined_non_empty("CG_SHVAR_INCLUDE_PATTERN") );

    #clear output variables:
    $CG_USER_VARS{'CG_SHVAR_LIST'} = "";

    return $var;
}

EOF_OPS
}
