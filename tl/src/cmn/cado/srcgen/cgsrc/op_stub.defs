{
CODEGEN_OP_STUBS := << EOF_OPS
sub rtrim_op
#process :rtrim postfix op
{
    my ($var) = @_;
    $var =~ s/\s+$//s;
    return $var;
}

sub trim_op
#process :trim postfix op
{
    my ($var) = @_;
    $var =~ s/^\s+//;
    $var =~ s/\s+$//s;
    return $var;
}

sub undef_op
#process :undef postfix op
{
    my ($var, $varname) = @_;
    #undefine $varname
    delete $CG_USER_VARS{&canonicalvarname($varname)} if (defined($CG_USER_VARS{&canonicalvarname($varname)}));
    $var = sprintf('${%s:undef}', $varname);   #same as lookup_def returns.
    return $var;
}

sub studyclass_op
#generate CG_ classname variables.
#return 1 if successful
{
    my ($classname) = @_;

    %CLASS_VARS = (); 
    &gen_classvars(\%CLASS_VARS, $classname);

    return 1;
}

sub m_op
#alias for :match
{
    return &match_op(@_);
}

sub g_op
#process :g postfix op
#:g - will grep contents of a stack variable, applying CG_GREP_SPEC to each element
#return 1 if match, else 0.
{
    my ($var) = @_;
    my $spec = $CG_USER_VARS{'CG_GREP_SPEC'};

    return 0 unless (defined($spec));

    #we only operate on stack variables:
    my @listin = split($;, $var);
#printf "g_op: var='%s' spec='%s' listin=(%s)\n", $var, $spec, join(",", @listin);

    my @listout = (); 

    my $cmd = sprintf("%s = grep(%s, %s);", '@listout', $spec, '@listin');
#printf "g_op: cmd='%s'\n", $cmd;

    my $ans = eval($cmd);  #returns the number of elements operated on.

    if ($@) {
        printf STDERR "%s[:g]: ERROR: line %d: evaluation of CG_GREP_SPEC (%s) failed: %s\n",
            $p, $LINE_CNT, $spec, $@;
        return "";
    } elsif (!defined($ans)) {
        #WARNING:  the $@ construct doesn't seem to work on perl 5.005_03.  RT 6/19/06
        printf STDERR "%s[:g]: ERROR: line %d: evaluation of CG_GREP_SPEC (%s) failed: %s\n",
            $p, $LINE_CNT, $spec, "ERROR in eval" ;
        return "";
    }

    return join($;, @listout) if ($ans > 0);
    return "";
}

sub match_op
#process :match postfix op
#:match or :m - will match against CG_MATCH_SPEC
#return 1 if match, else 0.
{
    my ($var) = @_;
    my $spec = $CG_USER_VARS{'CG_MATCH_SPEC'};

    return 0 unless (defined($spec));

#printf "expr_match: var='%s' spec='%s'\n", $var, $spec;

    my $ans = eval "\$var =~ $spec";

    if ($@) {
        printf STDERR "%s[match]: ERROR: line %d: evaluation of CG_MATCH_SPEC (%s) failed: %s\n",
            $p, $LINE_CNT, $spec, $@;
        return 0;
    } elsif (!defined($ans)) {
        #WARNING:  the $@ construct doesn't seem to work on perl 5.005_03.  RT 6/19/06
        printf STDERR "%s[match]: ERROR: line %d: evaluation of CG_MATCH_SPEC (%s) failed: %s\n",
            $p, $LINE_CNT, $spec, "ERROR in eval" ;
        return 0;
    }

    return ($ans eq ""? 0 : 1);
}

sub pad_op
#process :pad postfix op
#pad a number or string as specified by CG_PAD_SPEC
#Default is to zero-pad integers to width 2.
#CG_PAD_SPEC is take as an sprintf format spec.
{
    my ($var) = @_;
    my $spec = $CG_USER_VARS{'CG_PAD_SPEC'};

    if (!defined($spec)) {
        if (&is_integer($var)) {
            $spec = "%02d";
        } else {
            $spec = "%2s";
        }
    }

    printf "pad_op: var='%s' spec='%s'\n", $var, $spec if ($DEBUG);

    return sprintf($spec, $var);
}

sub s_op
#alias for :substitute
{
    return &dosubstitute('CG_SUBSTITUTE_SPEC', @_);
}

sub substitute_op
#process :substitute postfix op
#:substitute or :s - will match against CG_SUBSTITUTE_SPEC
{
    return &dosubstitute('CG_SUBSTITUTE_SPEC', @_);
}

#additional substitutions for nested substitution expressions:
sub s2_op { return &dosubstitute('CG_SUBSTITUTE_SPEC2', @_); }
sub s3_op { return &dosubstitute('CG_SUBSTITUTE_SPEC3', @_); }
sub s4_op { return &dosubstitute('CG_SUBSTITUTE_SPEC4', @_); }
sub s5_op { return &dosubstitute('CG_SUBSTITUTE_SPEC5', @_); }

sub dosubstitute
#implement substitution operators.
{
    my ($specvar, $var) = @_;

#printf STDERR "dosubstitute var='%s' specvar='%s'\n", $var, $specvar;

    my $spec = &lookup_def($specvar);
    return $var unless (&var_defined($specvar));

    my $savevar = $var;
    my $result = eval "\$var =~ $spec";

    if ($@) {
        printf STDERR "%s[substitute]: ERROR: line %d: evaluation of %s (%s) failed: %s\n",
            $p, $LINE_CNT, $specvar, $spec, $@;
        return $savevar;
    } elsif (!defined($result)) {
        #WARNING:  the $@ construct doesn't seem to work on perl 5.005_03.  RT 6/19/06
        printf STDERR "%s[substitute]: ERROR: line %d: evaluation of %s (%s) failed: %s\n",
            $p, $LINE_CNT, $specvar, $spec, "ERROR in eval" ;
        return $savevar;
    }

    return $var;
}

sub sl_op
#alias for :substituteliteral (literal substitute).
{
    return(substituteliteral_op(@_));
}

sub substituteliteral_op
#process :substituteliteral postfix op (literal substitute).
{
    my ($var) = @_;

    my $spec = &lookup_def('CG_SUBSTITUTE_SPEC');
    return $var unless (&var_defined('CG_SUBSTITUTE_SPEC'));

    my $input_spec = $spec;    #save original for messages.
    #skip over "s" in substitute spec:
    $spec =~ s/\s*s\s*//;

    #what is the delimiter?
    my $sep = substr($spec, 0, 1);

    #eliminate leading delimiter:
    $spec =~ s/^$sep//;

    #convert non-escaped separators to $;
    $spec =~ s/\\\\/!#%EsCaPeD_BaCkSlAsHeS%#!/g; #substitute escaped backslashes with special pattern
    $spec =~ s/$sep/$;/g;                        #convert sep chars to $;
    $spec =~ s/\\$;/$sep/g;                      #revert escaped sep chars
    $spec =~ s/!#%EsCaPeD_BaCkSlAsHeS%#!/\\\\/g; #revert escaped backslashes

    my (@tmp) = split($;, $spec, -1);
    my ($lit, $rep) = ("", "");
    my $modifiers = "";

    ###
    #Set subst/replace strings.  try to compensate for some common user errors.
    ###
    if ($#tmp == 2) {
        #case I:  3 elements:  lit/rep/modfiers  (modifiers can be empty)
        #                      0   1   2
        ($lit, $rep, $modifiers) = @tmp;
    } elsif ($#tmp == 1) {
        #case II:  2 elements:  lit/rep
        #                       0   1
        #we assume user forgot to add final separator.
        ($lit, $rep) = @tmp;
    } elsif ($#tmp > 2) {
        #case II:  >2 elements:  lit/rep/modifiers
        #                        0   $-1
        #either lit or rep has separators.  we assume lit and issue warning.

        my $nn = $#tmp;
#printf STDERR "nn=%d tmp=(%s)\n", $nn, join('!', @tmp);
        ($lit, $rep, $modifiers) = (join($sep, @tmp[0..$nn-2]), $tmp[$nn-1], $tmp[$nn]);

    printf STDERR "%s[substituteliteral]: WARNING: line %d: too many separators in CG_SUBSTITUTE_SPEC (%s) - assuming they belong to lhs.\n",
            $p, $LINE_CNT, $input_spec unless($QUIET);
    }

    my $isglobal = 0;
    $isglobal = 1 if ($modifiers eq "g");  #currently g is the only allowed modifier

#printf STDERR "substituteliteral_op: (sep lit rep modifiers isglobal)=('%s' '%s' '%s' '%s' '%s')\n", $sep, $lit, $rep, $modifiers, $isglobal;

    #return if $lit is the same as $rep - this is a nop and will prevent loop below from terminating.
    return $var if ($lit eq $rep);

    my ($idx, $len) = (index($var, $lit), length($lit));

#printf STDERR "substituteliteral_op: (idx,len)=(%d,%d)\n", $idx, $len;

    #if literal is found in var, then replace it:
    if ($idx >= 0) {
        substr($var, $idx, $len) = $rep;

        #replace all occurances if "g" specified:
        while ($isglobal && ($idx = index($var, $lit)) >= 0) {
            substr($var, $idx, $len) = $rep;
        }
    }

    return $var;
}

sub tounix_op
#convert a string to unix text
{
    my ($var) = @_;

    $var =~ s/\r\n/\n/gm;
    return $var;
}

sub todos_op
#convert a string to dos text
{
    my ($var) = @_;

    #make sure it is in unix format:
    $var =~ &tounix_op($var);

    $var =~ s/\n/\r\n/gm;
    return $var;
}

sub eq_op
#process :eq postfix op
#:eq - will compare against CG_COMPARE_SPEC
{
    my ($var) = @_;

    my $spec = $CG_USER_VARS{'CG_COMPARE_SPEC'};
    return 0 unless (defined($spec));
    return (($var == $spec)?1:0) if (&is_number($var) && &is_number($spec));
    return (($var eq $spec)?1:0);
}

sub ne_op
#process :ne postfix op
#:ne - will compare against CG_COMPARE_SPEC
{
    my ($var) = @_;

    my $spec = $CG_USER_VARS{'CG_COMPARE_SPEC'};
    return 0 unless (defined($spec));
    return (($var != $spec)?1:0) if (&is_number($var) && &is_number($spec));
    return (($var ne $spec)?1:0);
}

sub gt_op
#process :gt postfix op
#:gt - will compare against CG_COMPARE_SPEC
{
    my ($var) = @_;

    my $spec = $CG_USER_VARS{'CG_COMPARE_SPEC'};
    return 0 unless (defined($spec));
    return (($var > $spec)?1:0) if (&is_number($var) && &is_number($spec));
    return (($var gt $spec)?1:0);
}

sub ge_op
#process :ge postfix op
#:ge - will compare against CG_COMPARE_SPEC
{
    my ($var) = @_;

    my $spec = $CG_USER_VARS{'CG_COMPARE_SPEC'};
    return 0 unless (defined($spec));
    return (($var >= $spec)?1:0) if (&is_number($var) && &is_number($spec));
    return (($var ge $spec)?1:0);
}

sub lt_op
#process :lt postfix op
#:lt - will compare against CG_COMPARE_SPEC
{
    my ($var) = @_;

    my $spec = $CG_USER_VARS{'CG_COMPARE_SPEC'};
    return 0 unless (defined($spec));
    return (($var < $spec)?1:0) if (&is_number($var) && &is_number($spec));
    return (($var lt $spec)?1:0);
}

sub le_op
#process :le postfix op
#:le - will compare against CG_COMPARE_SPEC
{
    my ($var) = @_;

    my $spec = $CG_USER_VARS{'CG_COMPARE_SPEC'};
    return 0 unless (defined($spec));
    return (($var <= $spec)?1:0) if (&is_number($var) && &is_number($spec));
    return (($var le $spec)?1:0);
}

sub basename_op
#process :basename postfix op
#return basename of input var
{
    my ($var) = @_;

    #if not a path name, then just return simple name:
    return $var unless ( $var =~ /[\/\\]/ );

    return $1 if ( $var =~ /[\/\\]([^\/\\]*)$/ );
    return "";
}

sub dirname_op
#process :dirname postfix op
#return dirname of input var
{
    my ($var) = @_;
    $var =~ s/[\/\\][^\/\\]*$//;
    return $var;
}

sub suffix_op
#process :suffix postfix op
#return suffix of input var
{
    my ($var) = @_;

    return $1 if ( $var =~ /\.([^\.\\\/]*)$/ );
    return "";
}

sub root_op
#process :root postfix op
#return root of input var (i.e., var minus suffix).
{
    my ($var) = @_;

    return $1 if ( $var =~ /^(.*)\.[^\.\\\/]*$/ );
    return $var;
}

sub echo_op
#dump current contents of var to stdout (or current default output handle).
#useful in %void statements to display selected output.
{
    my ($var) = @_;
    print $var;
    return $var;
}

sub print_op
#alias for echo_op
{
    return &echo_op(@_);
}

sub eecho_op
#dump current contents of var to stderr.
{
    my ($var) = @_;
    print STDERR $var;
    return $var;
}

sub eprint_op
#alias for eecho_op
{
    return &eecho_op(@_);
}

sub top_op
#process :top postfix op
#:top - return the top (last in) element on the stack
{
    my ($var) = @_;

    return $var if (!defined($var) || $var eq "");

    my @tmp = split($;, $var, -1);  #note -1 => don't delete trailing empty fields.

#printf STDERR "top_op: var='%s' #tmp=%d\n", $var, $#tmp;
    return (pop @tmp);
}

sub car_op
#alias for :bottom, for lisp affectionados.
{
    return &bottom_op(@_);
}

sub cdr_op
#process :cdr postfix op, which is the stack minus it's :car.
{
    my ($var, $varname) = @_;

    return undef if (!defined($var));

    my @tmp = split($;, $var, -1);  #note -1 => don't delete trailing empty fields.
    shift @tmp;

    #if stack is now empty, return last element, but undef stack:
    if ($#tmp < 0) {
        return sprintf("\${%s:undef}", $varname);
    } else {
        return join($;, @tmp);
    }
}

sub bottom_op
#process :bottom postfix op
#:bottom - return the bottom (first in) element on the stack
{
    my ($var) = @_;

    return "" if ($var eq "");

    my @tmp = split($;, $var, -1);  #note -1 => don't delete trailing empty fields.

#printf STDERR "bottom_op: var='%s' #tmp=%d\n", $var, $#tmp;
    return (shift @tmp);
}

sub showstack_op
#display stack as list with $CG_STACK_DELIMITER separating elements.
{
    my ($var, $varname) = @_;
    return &undefname($varname)  unless (defined($var));

    my @tmp = split($;, $var, -1);  #note -1 => don't delete trailing empty fields.

    my $FS = &lookup_def('CG_STACK_DELIMITER');

    return sprintf("%s", join($FS, @tmp));
}

sub stacksize_op
#process :stacksize postfix op
#:stacksize - return the stacksize of a scalar.
#only variables created by %push will have a stacksize > 1
#undef stack has zero elements.  however an empty string on the stack is
#considered to have one element.
{
    my ($var, $varname) = @_;

    return 0 unless (&var_defined($varname));

    #this is a little confusing, but allows for stacks to have empty elements.
    #i.e., a stack has zero elements only if it is undefined.
    return 1 if ($var eq '');

    my @tmp = split($;, $var, -1);  #note -1 => don't delete trailing empty fields.

#printf STDERR "stacksize_op: varname='%s' value='%s' #tmp=%d\n", $varname, $var, $#tmp;

    return $#tmp +1;
}

sub stackminus_op
#process :stackminus postfix op
#:stackminus - subtract the members of CG_STACK_SPEC from current stack.
#duplicates are taken into account.
{
    my ($var) = @_;

    return $var if ($var eq "");

    my @thisStack = split($;, $var, -1);
#printf STDERR "thisStack=(%s)\n", join(",", @thisStack);
    my $specStack = $CG_USER_VARS{'CG_STACK_SPEC'};
    return $var unless (defined($specStack));

    my @specStack = split($;, $specStack, -1);
#printf STDERR "specStack=(%s)\n", join(",", @specStack);

    my @new = &MINUS(\@thisStack, \@specStack);
#printf STDERR "new=(%s)\n", join(",", @new);

    return join($;, @new);
}

sub unique_op
#process :unique postfix op
#:unique - eliminate duplicate values from a stack, preserving original order
{
    my ($var) = @_;

    return $var if ($var eq "");

    my @thisStack = split($;, $var, -1);

    my (%mark);
    for (@thisStack) { $mark{$_}++;}

    my @new = ();
    for (@thisStack) {
        push(@new, $_) if ($mark{$_});
        $mark{$_} = 0;
    }

#printf STDERR "thisStack=(%s)\n", join(",", @thisStack);
#printf STDERR "new=(%s)\n", join(",", @new);

    return join($;, @new);
}

sub dups_op
#:dups - discard all elements except those that are duplicated
{
    my ($var) = @_;

    return $var if ($var eq "");

    my @thisStack = split($;, $var, -1);

    my (%mark);
    for (@thisStack) { $mark{$_}++;}

    my @new = ();
    for (@thisStack) {
        push(@new, $_) unless ($mark{$_} == 1);
    }

#printf STDERR "thisStack=(%s)\n", join(",", @thisStack);
#printf STDERR "new=(%s)\n", join(",", @new);

    return join($;, @new);
}

sub pv_op
#alias for pragmavalue_op.
{
    return &pragmavalue_op(@_);
}

sub pragmavalue_op
#retrieve the value of the pragma named by the contents of a variable, or of
#the variable name if the contents are undefined.
{
    my ($var, $varname, $linecnt) = @_;
    #use varname if contents is undefined:
    my $pragma_name = ( (&isUndefinedVarnameValue($varname,$var) || $var eq "") ? $varname : $var);

#printf STDERR "pragmavalue_op A: varname='%s' var='%s' pragma_name='%s'\n", $varname, $var, $pragma_name;
#printf STDERR "%s='%s'\n", "pragma_preserve_multiline_lnewline", $pragma_preserve_multiline_lnewline;
#printf STDERR "%s='%s'\n", "pragma_trim_multiline_rnewline", $pragma_trim_multiline_rnewline;
#printf STDERR "%s='%s'\n", "pragma_copy", $pragma_copy;
#printf STDERR "%s='%s'\n", "pragma_update", $pragma_update;
#printf STDERR "%s='%s'\n", "pragma_echo_expands", $pragma_echo_expands;
#printf STDERR "%s='%s'\n", "pragma_require", $pragma_require;
#printf STDERR "%s='%s'\n", "pragma_debug", $pragma_debug;
#printf STDERR "%s='%s'\n", "pragma_ddebug", $pragma_ddebug;
#printf STDERR "%s='%s'\n", "pragma_quiet", $pragma_quiet;
#printf STDERR "%s='%s'\n", "pragma_verbose", $pragma_verbose;
#printf STDERR "%s='%s'\n", "pragma_filegen_notices_to_stdout", $pragma_filegen_notices_to_stdout;
#printf STDERR "%s='%s'\n", "pragma_clrifndef", $pragma_clrifndef;


    if ( !defined($PRAGMAS{$pragma_name}) ) {
        printf STDERR "%s: WARNING: '%s' is not a recognized pragma in :pragmavalue expression, line %d\n",
             $p, $pragma_name, $linecnt, join(", ", sort keys %PRAGMAS) unless ($QUIET);
        return "";
    }

    #####
    #look up value of pragma:
    #####

    if ($pragma_name eq 'reset_stack_delimiter') {
        #special case - no real value so just return what we would set it to:
        return "\t";
    }

    my $pragma_var = "pragma_" . $pragma_name;    #this is the variable we set internally.

    no strict "refs";
    my $pragma_ref = \${$pragma_var};
    use strict "refs";

    my $pragma_val = $$pragma_ref;

#printf STDERR "pragmavalue_op: pragma_var='%s' pragma_val='%s'\n", $pragma_var, defined($pragma_val)? $pragma_val : "undef";

    return $pragma_val;
}

sub to_txtm
#convert a unix time to transaction date/time format
#Usage:
#   $theTime = time;
#   $yyyymmddhhmmss = &txtm::to_txtm($theTime);
{
    my($utime) = @_;

    my(@trec) = gmtime($utime);

    return sprintf("%04d%02d%02d%02d%02d%02d",
        $trec[5] + 1900,
        $trec[4] +1,
        $trec[3],
        $trec[2],
        $trec[1],
        $trec[0]);
}

sub modtime_op
#return the last modified time of a file, in the form YYYYMMDDHHMMSS
#NULL if not a file.
{
#record defs for stat buf:
#$N_STATBUF = 12;
#($DEV, $INO, $MODE, $NLINK, $UID, $GID, $RDEV, $SIZE,
# $ATIME, $MTIME, $CTIME, $BLKSIZE, $BLOCKS) =  (0..$N_STATBUF);

    my ($fn) = @_;
    my @rec = stat($fn);

#printf STDERR "modtime_op: fn='%s' rec=(%s)\n", $fn, join(',', @rec);

    return "NULL" unless ($#rec >= 0);

    #convert to yyyymmddhhmmss format:
    return to_txtm($rec[9]);
}

sub createtime_op
#return the create time of a file, in the form YYYYMMDDHHMMSS
#NULL if not a file.
{
    my ($fn) = @_;
    my @rec = stat($fn);

    return "NULL" unless ($#rec >= 0);
    return to_txtm($rec[10]);
}

sub openfile_op
#process :openfile postfix op
#open a file if it is open. return error string or empty if no error.
{
    my ($fn, $varname) = @_;

    my $fhref = $CG_OPEN_FILE_DESCRIPTORS{$fn};
    my $fhidx = -1;

    if (defined($fhref)) {
        #then close before re-open:
        close $fhref;
        $fhidx = $CG_OPEN_FILE_FD_INDEXES{$fn};
    } else {
        #get the next file reference:
        $fhidx = &get_avaliable_filehandle("open_fileop");

        if ($fhidx < 0) {
            return sprintf("%s: ERROR: out of file descriptors (max is %d).", $p, $LAST_TEMPLATE_FD_KEY+1);
        }

        $fhref = $TEMPLATE_FD_REFS[$fhidx];
    }


    if (!open($fhref, $fn)) {
        &free_filehandle($fhidx, "open_fileop") if ($fhidx >= 0);   #free if we allocated filehandle
        my $errtxt = sprintf("%s", $!);
        return $errtxt unless ($errtxt eq "");
        return "UNKNOWN ERROR";
    }


    #init line contents, count for newly opened file:
    $CG_OFD_CURRENTLINE{$fn} = "";
    $CG_OFD_CURRENTLINECOUNT{$fn} = 0;

    #save file-handle:
    $CG_OPEN_FILE_DESCRIPTORS{$fn} = $fhref;
    $CG_OPEN_FILE_FD_INDEXES{$fn} = $fhidx;

    return "";
}

sub getnextline_op
#process :getnextline postfix op
#get the next line of a file if it is open.
#return varname if line is defined, otherwise, return "".
#undefine varname if file is not open or we have read past the end.
{
    my ($fn, $varname) = @_;

    if ($fn eq "-" || $fn =~ /stdin/i) {
        my $line = <>;
        if (!defined($line)) {
            delete $CG_USER_VARS{&canonicalvarname($varname)} if (defined($CG_USER_VARS{&canonicalvarname($varname)}));
            return "";
        }
        chomp $line;
        $CG_OPEN_FILE_DESCRIPTORS{'<STDIN>'} = '<STDIN>';
        $CG_OFD_CURRENTLINE{'<STDIN>'} = $line;
        ++$CG_OFD_CURRENTLINECOUNT{'<STDIN>'};    #this keeps a tally of how many lines read from stdin

        #we read a line from stdin.
        $CG_USER_VARS{&canonicalvarname($varname)} = '<STDIN>';  #normalize name of stdin
        return $varname;
    }

    my $fhref = $CG_OPEN_FILE_DESCRIPTORS{$fn};
    my $line = <$fhref> if (defined($fhref));

    if (!defined($fhref) || !defined($line)) {
        delete $CG_USER_VARS{&canonicalvarname($varname)} if (defined($CG_USER_VARS{&canonicalvarname($varname)}));
        return "";
    }

    #otherwise, make a copy of current line, and increment line count:
    if (defined($line)) {
        chomp $line;
        $CG_OFD_CURRENTLINE{$fn} = $line;
        ++$CG_OFD_CURRENTLINECOUNT{$fn};
    }

    printf "getnextline_fileop: varname=%s fn=%s line='%s'\n", $varname, $fn, $line if ($DEBUG);

    #return the name of the input variable, for use in %whiledef loops:
    return $varname;
}

sub currentline_op
#process :currentline postfix op
#return the current input line of a file, or undef varname if file is closed
{
    my ($fn, $varname) = @_;

    return $CG_OFD_CURRENTLINE{$fn} if (defined($CG_OFD_CURRENTLINE{$fn}));

    #otherwise, undefine the caller's variable:
    delete $CG_USER_VARS{&canonicalvarname($varname)} if (defined($CG_USER_VARS{&canonicalvarname($varname)}));
    #otherwise, undefine the caller's variable:
    delete $CG_USER_VARS{&canonicalvarname($varname)} if (defined($CG_USER_VARS{&canonicalvarname($varname)}));
    return sprintf('${%s}', $varname);   #same as lookup_def returns.
}

sub currentlinenumber_op
#process :currentlinenumber postfix op
#(1..nlines), 0 => file closed
{
    my ($fn, $varname) = @_;

    return $CG_OFD_CURRENTLINECOUNT{$fn} if (defined($CG_OFD_CURRENTLINECOUNT{$fn}));

    return 0;    #allows %ifnot to detect that file is not open
}

sub closefile_op
#process :closefile postfix op
#close a file if it is open. set $var to error or empty if no error.
{
    my ($fn, $varname) = @_;
    my $fhref = $CG_OPEN_FILE_DESCRIPTORS{$fn};

    if (defined($fhref)) {
        #then close:
        close $fhref;

        #clear variables related to this file:
        delete $CG_OPEN_FILE_DESCRIPTORS{$fn} if (defined($CG_OPEN_FILE_DESCRIPTORS{$fn}));
        delete $CG_OFD_CURRENTLINE{$fn} if (defined($CG_OFD_CURRENTLINE{$fn}));
        delete $CG_OFD_CURRENTLINECOUNT{$fn} if (defined($CG_OFD_CURRENTLINECOUNT{$fn}));

        if (defined($CG_OPEN_FILE_FD_INDEXES{$fn})) {
            &free_filehandle($CG_OPEN_FILE_FD_INDEXES{$fn}, "close_fileop");
            delete $CG_OPEN_FILE_FD_INDEXES{$fn};
        }
    }

    #we don't return any errors for now...

    return "";
}

sub eoltrim_op
#trim whitespace preceeding newlines
{
    my ($var) = @_;
    $var =~ s/[ \t]+\n/\n/g;
    return $var;
}

sub eolsqueeze_op
#compress multiple empty lines into a single empty line.
{
    my ($var) = @_;

    $var =~ s/\n\n\n+/\n\n/g;

    return $var;
}

sub lspace_op
#process :lspace postfix op
#add one space to beginning of string iff it is a non-empty string:
{
    my ($var) = @_;
    $var = " $var" unless ($var eq "");
    return $var;
}

sub rspace_op
#process :rspace postfix op
{
    my ($var) = @_;
    #add one space to end of string iff it is a non-empty string:
    $var = "$var " unless ($var eq "");
    return $var;
}

sub space_op
#process :space postfix op
#use this to add spaces to empty string.
{
    my ($var) = @_;
    return $var = $var . " ";
}

sub rnewline_op
#append trailing (right) newline iff non-empty string.
{
    my ($var) = @_;
    #add one newline to end of string iff it is a non-empty string:
    $var = "$var\n" unless ($var eq "");
    return $var;
}

sub lnewline_op
#process :lnewline postfix op
#insert leading (left) newline iff non-empty string.
{
    my ($var) = @_;
    $var = "\n$var" unless ($var eq "");
    return $var;
}

sub newline_op
#alias for nl_op
{
    return &nl_op(@_);
}

sub nl_op
#append trailing newline unconditionally.
{
    my ($var) = @_;
    return "$var\n";
}

sub fixeol_op
#force at most one newline at the end of the string
{
    my ($var) = @_;

    #ignore empty strings or strings that already have a newline:
    return $var if ($var eq "" || $var =~ /\n$/);

    $var = "$var\n";
    return $var;
}

sub oneline_op
#process :oneline postfix op
#replace \s*EOL\s* sequences with a single space, and trim result:
{
    my ($var) = @_;

    $var =~ s/\s*(\r\n)+\s*/ /g;
    $var =~ s/\s*(\n\r)+\s*/ /g;
    $var =~ s/\s*\n+\s*/ /g;
    $var =~ s/\s*\r+\s*/ /g;

    #trim:
    $var =~ s/^\s+//;
    $var =~ s/\s+$//;

    return $var;
}

sub rangelb_op
#process :rangelb postfix op
#Interpret m..n as a range value.
#    :rangelb => m..n => m
#    :rangeub => m..n => n
#    common behavior
#        strings are trimmed
#        if missing range operator "..", then reflect original value
#        "" => 0
#        m => m
{
    my ($var) = @_;

    #trim leading/trailing whitespace:
    $var = $1 if ($var =~ /^\s*([^\s]+)\s*$/);

    return 0 if ($var eq "");

    my @lbub  = split(/\.\./, $var, 2);

    return $lbub[0] if ($#lbub >= 0);

    return $var;
}

sub rangeub_op
#process :rangeub postfix op
#Interpret m..n as a range value.
#    :rangelb => m..n => m
#    :rangeub => m..n => n
#    common behavior
#        strings are trimmed
#        if missing range operator "..", then reflect original value
#        "" => 0
#        m => m
{
    my ($var) = @_;

    #trim leading/trailing whitespace:
    $var = $1 if ($var =~ /^\s*([^\s]+)\s*$/);

    return 0 if ($var eq "");

    my @lbub  = split(/\.\./, $var, 2);

    return $lbub[0] if ($#lbub == 0);
    return $lbub[1] if ($#lbub == 1);

    return $var;
}

sub isint_op
#process :isint postfix op
#returns 1 if <val> is a positive integer, else zero.
{
    my ($var) = @_;

    return 1 if ( $var =~ /^\s*\d+\s*$/ );
    return 0;
}

sub split_op
#process :split postfix op
#splits variable into a push/pop reference
#default split pattern is /[\t,]/
{
    my ($var) = @_;

    &reset_split_pattern() unless (&var_defined('CG_SPLIT_PATTERN'));
    my $spat = $CG_USER_VARS{'CG_SPLIT_PATTERN'};

    #we are going to make a STACK var out of our var, so we are really just doing
    #a substitute op:
    my $savevar = $var;
    my $result = 0;

#printf STDERR "SPLIT BEFORE spat='%s' var='%s'\n", $spat, $var;
    
    if ($spat =~ /^\/.*\/$/ ) {
        #split spec has slashes.
        eval "\$var =~ s${spat}$;/g";
    } else {
        #split spec has no slashes.
        eval "\$var =~ s/${spat}/$;/g";
    }

#my @rec = split(/$;/, $var, -1);
#printf STDERR "SPLIT AFTER spat='%s' var='%s' rec=(%s) cnt=%d\n", $spat, $var, join(',', @rec), $#rec;

    if ($@) {
        printf STDERR "%s[split]: ERROR: line %d: evaluation of CG_SPLIT_PATTERN (%s) failed for var '%s': %s\n",
            $p, $LINE_CNT, $spat, $var, $@;
        return $savevar;
    } elsif (!defined($result)) {
        #WARNING:  the $@ construct doesn't seem to work on perl 5.005_03.  RT 6/19/06
        printf STDERR "%s[split]: ERROR: line %d: evaluation of CG_SPLIT_PATTERN (%s) failed for var '%s': %s\n",
            $p, $LINE_CNT, $spat, $var, "ERROR in eval" ;
        return $savevar;
    }

    return $var;
}

sub onecol_op
#process :onecol postfix op
{
    my ($var) = @_;

    #trim, then replace \s+ sequences with newlines:
    $var =~ s/^\s+//;
    $var =~ s/\s+$//;
    #Q: should I use \r\n on DOS?
    $var =~ s/\s+/\n/g;

    return $var;
}

sub method2rec_op
#process :method2rec postfix op
#convert a java method signature to a tab separated record:
#parse a line containing a java method signature declaration, and output
#a tab-separated record containing:
#    (method attributes, return type, name(parmeters), exceptions thrown) 
{
    my ($var) = @_;

    #make input easier to parse:
    $var = &oneline_op($var);

    #get rid of any tabs:
    $var =~ s/\t//g;

    #get rid of any terminating semi-colons:
    $var =~ s/\s*;.*$//;

    #get rid of any open-brace expressions:
    $var =~ s/\s*{.*$//; #}

    #pull out throws clause:
    my $throws = "";
    #WARNING: we localize the scope of $1 from the match, as perl leaves the
    #most recent match defined until it is overriden, which means defined($1) is always
    #true after the first match.  not what we want...
    {
        $var =~ s/\s+throws\s+(.*)//;
        $throws = $1 if (defined($1));
    }

#printf STDERR "method2rec: var='%s' throws='%s'\n", $var, $throws;

    #pull out methodname(args...):
    my $name = "";
    {
        #get formal parameters:
        $var =~ s/\s*(\(.*)$//;
        $name = $1 if (defined($1));
        #get method name:
        $var =~ s/\s+(\S+)$//;
        $name = "$1$name" if (defined($1));
    }

#printf STDERR "method2rec: var='%s' name='%s'\n", $var, $name;

    #pull out return type:
    my $returns = "";
    #get array brackets if present:
    {
        $var =~ s/\s*(\[.*)$//;
        $returns = $1 if (defined($1));
        #get return type name
        #note that pattern can start at beginning of line if interface
        #with no attributes, because access attribute (public,private...)  is optional:
        $var =~ s/\s*(\S+)$//;
        $returns = "$1$returns" if (defined($1));
    }

#printf STDERR "method2rec: var='%s' returns='%s'\n", $var, $returns;

    #whatever is left are the method attributes:
    my $attributes = $var;

#printf STDERR "method2rec: var='%s' attributes='%s'\n", $var, $attributes;

    #return tab-separated record:
    return join("\t", $attributes, $returns, $name, $throws);
}

sub ltrim_op
#process :ltrim postfix op
{
    my ($var, $varname, $linecnt) = @_;
    $var =~ s/^\s+//;
    return $var;
}

sub antvar_op
#process :antvar postfix op
#convert to an ant variable reference:
#  $foo:nameof:antvar -> ${foo}.
{
    my ($var) = @_;
    return '$' . "{$var}";
}

sub cgvar_op
#process :cgvar postfix op
#wrap value as an cado template reference - e.g., $foo:nameof:cgvar -> {=foo=}
{
    my ($var) = @_;
    return '{=' . $var . '=}';
}

sub pl2path_op
#INPUT: perl module reference, e.g., Release::Build::Cmd::build
#OUTPUT: pathname of perl script, e.g., Release/Build/Cmd/build.pl
#NOTE:  unix only
{
    my ($varvalue) = @_;

    $varvalue = &prlpkg2path_op($varvalue) . '.pl';

    return $varvalue;
}

sub pm2path_op
#INPUT: perl module name, e.g., Release::Build::Cmd::build
#OUTPUT: pathname of perl module, e.g., Release/Build/Cmd/build.pm
#NOTE:  unix only
{
    my ($varvalue) = @_;

    $varvalue = &prlpkg2path_op($varvalue) . '.pm';

    return $varvalue;
}

sub prlpkg2path_op
#INPUT: perl package name, e.g., Release::Build::Cmd
#OUTPUT: pathname of perl package directory, e.g., Release/Build/Cmd
#NOTE:  unix only
{
    my ($varvalue) = @_;

    $varvalue =~ s/::/\//g;

    return $varvalue;
}

sub path2pm_op
#INPUT: pathname with or without .pm or .pl suffix
#OUTPUT: perl module name
{
    my ($varvalue, $varname, $linecnt) = @_;

    $varvalue =~ s/\.p[ml]$//g;
    $varvalue =~ s/\//::/g;

    return $varvalue;
}

sub q_op
#wrap contents of var in single quotes.
{
    my ($var) = @_;
    return "'" . $var . "'";
}

sub quote_op
#alias for q_op
{
    return &q_op(@_);
}

sub dq_op
#wrap contents of var in single quotes.
{
    my ($var) = @_;
    return '"' . $var . '"';
}

sub dquote_op
#alias for q_op
{
    return &q_op(@_);
}

sub xmlcommentblock_op
#process :xmlcommentblock postfix op
#wrap $var in multi-line xml comment:
#wrap the input string in an xml comment
{
    my ($var) = @_;

    my $eolpat = "\n";
    if ($var =~ /\r/) {
        #set to use dos line endings:
        $eolpat = "\r\n";
    }

    my @tmp = split($eolpat, $var);

    $var = sprintf("<!--\n # %s\n-->", join("\n # ", @tmp));

#    <!--
#     # this
#     # is a comment
#    -->

    return $var;
}

sub xmlcomment_op
#process :xmlcomment postfix op
#wrap $var in xml comment:
{
    my ($var) = @_;
    return sprintf("<!-- %s -->", $var);
}

sub stripxmlcomments_op
#INPUT:  string containing xml snippet
#OUTPUT: string with xml comments stripped out.
{
    my ($varvalue) = @_;

    $varvalue =~ s/<!--.*?-->//gs;

    return $varvalue;
}

sub tab_op
#process :tab postfix op
#use this to add tabs to empty string.
{
    my ($var) = @_;
    return $var . "\t";
}

sub tolower_op
#process :tolower postfix op
{
    my ($var) = @_;
    $var =~ tr/[A-Z]/[a-z]/;
    return $var;
}

sub toupper_op
#process :toupper postfix op
{
    my ($var) = @_;
    $var =~ tr/[a-z]/[A-Z]/;
    return $var;
}

#init hex decode map:
my %hex_decode_map = map { sprintf( "%02X", $_ ) => chr($_) } ( 0 ... 255 );

sub urlencode_op
{
    my ($value) = @_;
    $value =~ s/([^a-zA-Z_0-9])/"%" . uc(sprintf "%02X" , unpack("C", $1))/egs;
    return ($value);
}

sub urldecode_op
#process :urldecode postfix op
#decode a url encoded string to a regular string.
{
    my ($url) = @_;
    return unless $url;

    # Decode percent encoding
    $url =~ s/%([a-fA-F0-9]{2})/$hex_decode_map{$1}/egs;
    return $url;
}

sub hexencode_op
#process :hexencode postfix op
#encode a regular string to hex representation.
{
    my ($value) = @_;
    $value =~ s/(.)/uc(sprintf "%02X" , unpack("C", $1))/egs;
    return ("HEX_" . $value);
}

sub hexdecode_op
#process :hexdecode postfix op
#decode a hex encoded string to a regular string.
{
    my ($hexstr) = @_;
    return unless $hexstr =~ /^HEX_/;

    $hexstr =~ s/^HEX_//;

    $hexstr =~ s/([A-F0-9]{2})/$hex_decode_map{$1}/egs;
    return $hexstr;
}

sub cap_op
#process :cap postfix op
#this op capitalizes the first letter of a string.
{
    my ($var) = @_;
    #ignore leading spaces:
    $var =~ s/^(\s*)([a-z])(.*)$/$1\u$2$3/;
    return $var;
}

sub uncap_op
#process :uncap postfix op
#this op uncapitalizes the first letter of a string.
{
    my ($var) = @_;
    #ignore leading spaces:
    $var =~ s/^(\s*)([A-Z])(.*)$/$1\l$2$3/;
    return $var;
}

sub i_op
#alias for :incr
{
    return &incr_op(@_);
}

sub incr_op
#process :incr postfix op
{
    my ($var) = @_;

    #we do fixed-width increment, e.g., 001, 002, ... 999
    my $tmp = $var; $tmp =~ s/^\s*[-+]\s*//;
    $var = sprintf "%.*d", length($tmp), $var+1;

    return $var;
}

sub decr_op
#process :decr postfix op
{
    my ($var) = @_;

    #we do fixed-width decrement, e.g., 999, 998, ... 000;
    my $tmp = $var; $tmp =~ s/^\s*[-+]\s*//;
    $var = sprintf "%.*d", length($tmp), $var-1;

    return $var;
}

sub env_op
#process :env postfix op
{
    my ($var, $varname, $linecnt) = @_;

    #use varname if contents is undefined:
    my $env_name = (&isUndefinedVarnameValue($varname,$var) ? $varname : $var);

    if (defined($ENV{$env_name})) {
        $var = $ENV{$env_name};
    } else {
        printf STDERR "%s: WARNING: line %d:  \$%s:%s is UNDEFINED.\n", $p, $linecnt, $env_name, "env" if ($VERBOSE);
        $var = "";
    }

    return $var;
}

sub pwd_op
#process :pwd postfix op
{
    my ($var) = @_;

    #use the system library since it is more portable:
    use Cwd;
    $var = getcwd();

    return $var;
}

sub freq_op
#process :freq postfix op
#get the frequency of each line, and ouput in the form:
#  <cnt><tab><unique_lines>
#where <unique_lines> is the original data with leading/trailing whitespace trimmed
{
    my ($var) = @_;
    my $eolpat = "\n";
    if ($var =~ /\r/) {
        #set to use dos line endings:
        $eolpat = "\r\n";
    }
    my @tmp = split($eolpat, $var);

#printf STDERR "freq: tmp=(%s)\n", join(',', @tmp);

    #this is much faster than a for loop:
    @tmp = grep (s/^\s*//, @tmp);
    @tmp = grep (s/\s*$//, @tmp);

    #now count unique occurances:
    my %FREQ = ();
    grep (++$FREQ{$_}, @tmp);

#printf "keys FREQ=(%s)\n", join(",", sort keys %FREQ);
#printf "values FREQ=(%s)\n", join(",", sort values %FREQ);

    @tmp = grep($_ = "$FREQ{$_}\t$_", sort keys %FREQ);

    return join("\n", @tmp);
}

sub nameof_op
#process :nameof postfix op
{
    my ($var, $varname) = @_;
    return $varname;
}

sub valueof_op
#process :valueof postfix op
{
    my ($var, $varname, $linecnt) = @_;

    #show the value of the variable named by $var:
    if (&var_defined(&canonicalvarname($var))) {
        $var = $CG_USER_VARS{&canonicalvarname($var)};
    } else {
        printf STDERR "%s: WARNING: line %d:  \$%s:%s is UNDEFINED\n", $p, $linecnt, $var, "valueof" unless ($QUIET);
        $var = sprintf("\${%s:undef}", $varname);
    }

    return $var;
}

sub a_op
#alias for :assign
{
    return &assign_op(@_);
}

sub assign_op
#process :assign postfix op
{
    my ($var, $varname, $linecnt) = @_;

    #update the value of $var:
    $CG_USER_VARS{&canonicalvarname($varname)} = $var;
    printf STDERR "eval_postfix_op:  var='%s' CG_USER_VARS{%s}='%s'\n", $var, $varname, $CG_USER_VARS{&canonicalvarname($varname)} if ($DEBUG);

    return $var;
}

sub append_op
#process :append postfix op - append a value to a variable.
{
    my ($var, $varname, $linecnt) = @_;

    $CG_USER_VARS{&canonicalvarname($varname)} = "" unless (defined($CG_USER_VARS{&canonicalvarname($varname)}));
    $CG_USER_VARS{&canonicalvarname($varname)} .= $var;
    printf STDERR "eval_postfix_op:  var='%s' CG_USER_VARS{%s}='%s'\n", $var, $varname, $CG_USER_VARS{&canonicalvarname($varname)} if ($DEBUG);

    return $var;
}

sub insert_op
#process :insert postfix op - prepend a value to a variable.
{
    my ($var, $varname, $linecnt) = @_;

    $CG_USER_VARS{&canonicalvarname($varname)} = "" unless (defined($CG_USER_VARS{&canonicalvarname($varname)}));
    $CG_USER_VARS{&canonicalvarname($varname)} = $var . $CG_USER_VARS{&canonicalvarname($varname)};

    printf STDERR "eval_postfix_op:  var='%s' CG_USER_VARS{%s}='%s'\n", $var, $varname, $CG_USER_VARS{&canonicalvarname($varname)} if ($DEBUG);

    return $var;
}

sub clr_op
#set a variable to empty string.
{
    my ($var, $varname, $linecnt) = @_;
    return &assign_op("", $varname, $linecnt);
}

sub clrifndef_op
#clear variable if it is not defined
{
    my ($var, $varname, $linecnt) = @_;

    if (!defined($CG_USER_VARS{&canonicalvarname($varname)})) {
        return &assign_op("", $varname, $linecnt);
    }

    return $var;
}

sub zero_op
#set a variable to zero.
{
    my ($var, $varname, $linecnt) = @_;
    return &assign_op(0, $varname, $linecnt);
}

my @RCS_KEYWORDS = (
        "Author",
        "Date",
        "Header",
        "Id",
        "Locker",
        "Log",
        "Name",
        "RCSfile",
        "Revision",
        "Source",
        "State",
    );

sub stripRcsKeywords_op
#strip all RCS keywords from the string
{
    my ($var) = @_;

    #optimization - don't look at strings unless there is at
    #least one possible rcs keyword sequence:
    return $var unless ($var =~ /\$[A-Z][a-z]/ );

    for my $kw (@RCS_KEYWORDS) {
        #this will only strip keywords that are properly terminated.
        #for example, $Id .. <EOL>  will not be touched,
        #but $Id ... $ will be deleted.
        $var =~ s/\$$kw[^\$\n]*\$//g
    }

    return $var;
}

sub crcfile_op
#return the crc of the file named by the string.
#open the file directly, and if that fails, look in CG_ROOT.
#return zero if file is not readable, otherwise,
#hex number representing the crc.
{
    my ($fn) = @_;
    my $crc = "0";

    #if we can read file directly...
    if ( -r $fn ) {
        $crc =  sprintf("%x", &pcrc::CalculateFileCRC($fn));
        return "$crc";
    } else {
        #otherwise, look in CG_ROOT:
        my ($cgfn) = &path::mkpathname($CG_USER_VARS{'CG_ROOT'}, $fn);

        if ( -r $cgfn ) {
            $crc =  sprintf("%x", &pcrc::CalculateFileCRC($cgfn));
            return "$crc";
        }
    }

    return "0";    #return zero if we cannot open file
}

sub crcstr_op
#return the crc of the contents of a string
{
    my ($var) = @_;

    my $tmpfile_fullpath = &write_string_to_cg_tmp_file($var);
    if ($tmpfile_fullpath eq "NULL") {
        #we treat this as an internal error (as opposed to a user error):
        printf STDERR "%s[%s]: ERROR: line %d: cannot create temp file.\n",
            $p, "crcstr_op", $LINE_CNT unless ($QUIET);
        ++ $GLOBAL_ERROR_COUNT;
        return "0";    #return zero if we cannot open file
    }

    #return crc of temp file containing string:
    my $crc = &crcfile_op($tmpfile_fullpath);
    unlink $tmpfile_fullpath;
    return $crc;
}

sub crc_op
#return crcfile, and if that fails, crcstr.
#use explicit ops if you want to force it one way or the other.
{
    my ($var) = @_;
    my $crc = 0;

    $crc =  &crcfile_op($var);
    return $crc if ( $crc ne "0" );

    #otherwise, return crc of string:
    return &crcstr_op($var);
}

EOF_OPS
}
